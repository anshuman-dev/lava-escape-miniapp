<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lava Escape</title>
    
    <!-- Farcaster Mini App Meta Tags - 2025 -->
    <meta name="fc:miniapp" content='{"version":"1","imageUrl":"https://lava-escape.netlify.app/splash.png","button":{"title":"üåã Escape the Lava","action":{"type":"launch_frame","name":"üåã Lava Escape","url":"https://lava-escape.netlify.app","splashImageUrl":"https://lava-escape.netlify.app/splash.png","splashBackgroundColor":"#1a1a2e"}}}' />
    <!-- Backward compatibility -->
    <meta name="fc:frame" content='{"version":"1","imageUrl":"https://lava-escape.netlify.app/splash.png","button":{"title":"üåã Escape the Lava","action":{"type":"launch_frame","name":"üåã Lava Escape","url":"https://lava-escape.netlify.app","splashImageUrl":"https://lava-escape.netlify.app/splash.png","splashBackgroundColor":"#1a1a2e"}}}' />
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="üåã Lava Escape - Jump to Survive!" />
    <meta property="og:description" content="Help the stickman escape rising lava! Jump between platforms with onchain lives and compete on the Base L2 leaderboard." />
    <meta property="og:image" content="https://lava-escape.netlify.app/splash.png" />
    <meta property="og:url" content="https://lava-escape.netlify.app" />
    <meta property="og:type" content="website" />
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .game-container {
            background: #1a1a2e;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 400px;
            width: 100%;
        }
        
        .game-header {
            text-align: center;
            color: #fff;
            margin-bottom: 15px;
        }
        
        .stats {
            display: flex;
            justify-content: space-between;
            color: #00ff88;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .farcaster-info {
            display: none;
            text-align: center;
            color: #00ff88;
            font-size: 12px;
            margin-bottom: 10px;
            padding: 5px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 5px;
        }
        
        canvas {
            border: 2px solid #00ff88;
            border-radius: 5px;
            display: block;
            margin: 0 auto;
            background: linear-gradient(180deg, #87CEEB 0%, #98FB98 100%);
        }
        
        .controls {
            text-align: center;
            color: #fff;
            font-size: 12px;
            margin-top: 10px;
        }
        
        .social-actions {
            display: none;
            text-align: center;
            margin-top: 10px;
        }
        
        .social-btn {
            background: #8a63d2;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            margin: 0 5px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        
        .social-btn:hover {
            background: #7a53c2;
        }
        
        .social-btn.primary {
            background: #00ff88;
            color: #000;
        }
        
        .social-btn.primary:hover {
            background: #00cc6a;
        }
        
        .intro-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            color: #fff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #ff6b6b;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        
        .btn {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
        }
        
        .btn:hover {
            background: #00cc6a;
        }
        
        .danger-btn {
            background: #ff6b6b;
            color: #fff;
        }
        
        .danger-btn:hover {
            background: #ff5252;
        }

        .debug-info {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
            padding: 5px;
            background: rgba(0,0,0,0.3);
            border-radius: 3px;
        }
        
        .buy-lives-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #00ff88;
            text-align: center;
            color: #fff;
            max-width: 400px;
            width: 90%;
        }
        
        .lives-options {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .lives-options .btn {
            font-size: 10px;
            padding: 8px 12px;
            margin: 0;
        }
        
        .leaderboard-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .leaderboard-modal .modal-content {
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 5px;
            font-size: 12px;
        }
        
        .leaderboard-entry:nth-child(1) { background: rgba(255, 215, 0, 0.3); } /* Gold */
        .leaderboard-entry:nth-child(2) { background: rgba(192, 192, 192, 0.3); } /* Silver */
        .leaderboard-entry:nth-child(3) { background: rgba(205, 127, 50, 0.3); } /* Bronze */
        
        .player-rank {
            font-weight: bold;
            width: 30px;
        }
        
        .player-address {
            font-family: monospace;
            font-size: 10px;
            opacity: 0.8;
        }
        
        .player-score {
            font-weight: bold;
            color: #00ff88;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h2>üåã LAVA ESCAPE</h2>
            <div class="farcaster-info" id="farcasterInfo">
                <span id="userInfo">Playing in Farcaster!</span>
            </div>
            <div class="stats">
                <span>‚ù§Ô∏è Lives: <span id="lives">3</span></span>
                <span>Jumps: <span id="jumps">0</span></span>
                <span>Level: <span id="level">1</span></span>
                <span>Speed: <span id="speed">1.0x</span></span>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="360" height="500"></canvas>
        
        <div class="controls">
            üéÆ Arrow Keys/WASD ‚Ä¢ Space/Click to jump ‚Ä¢ ESCAPE THE LAVA!
            <div id="debugInfo" class="debug-info" style="display: none;">
                <div>Environment: <span id="envStatus">Checking...</span></div>
                <div>SDK Status: <span id="sdkStatus">Loading...</span></div>
                <div>Ready Called: <span id="readyStatus">Not yet</span></div>
            </div>
        </div>
        
        <div class="social-actions" id="socialActions">
            <button class="social-btn primary" id="shareScore" onclick="shareScore()">üìä Share Score</button>
            <button class="social-btn" id="addToApp" onclick="addToFarcaster()">‚ûï Add to App</button>
            <button class="social-btn" id="showLeaderboard" onclick="showLeaderboard()">üèÜ Leaderboard</button>
        </div>
        
        <div class="intro-screen" id="introScreen">
            <h3>ü§î Hey... what's happening?</h3>
            <p id="introText">Everything seems normal...</p>
            <button class="btn" id="continueBtn" onclick="nextIntroStep()">Continue</button>
        </div>
        
        <div class="game-over" id="gameOver">
            <h3 id="gameOverTitle">üî• BURNED BY LAVA!</h3>
            <p id="gameOverMessage">You couldn't escape in time!</p>
            <p>Final Jumps: <span id="finalJumps">0</span></p>
            <p>Level Reached: <span id="finalLevel">1</span></p>
            <button class="btn" onclick="restartGame()">üîÑ Try Again</button>
        </div>
        
        <div class="buy-lives-modal" id="buyLivesModal" style="display: none;">
            <div class="modal-content">
                <h3>üíÄ Out of Lives!</h3>
                <p>Purchase more lives to continue playing:</p>
                <div class="lives-options">
                    <button class="btn" onclick="buyLivesWithETH(1)">
                        1 Life - 0.001 ETH
                    </button>
                    <button class="btn" onclick="buyLivesWithETH(3)">
                        3 Lives - 0.003 ETH
                    </button>
                    <button class="btn" onclick="buyLivesWithETH(5)">
                        5 Lives - 0.005 ETH
                    </button>
                </div>
                <div class="lives-options">
                    <button class="btn" onclick="buyLivesWithUSDC(1)">
                        1 Life - 3 USDC
                    </button>
                    <button class="btn" onclick="buyLivesWithUSDC(3)">
                        3 Lives - 9 USDC
                    </button>
                    <button class="btn" onclick="buyLivesWithUSDC(5)">
                        5 Lives - 15 USDC
                    </button>
                </div>
                <button class="btn danger-btn" onclick="closeBuyLivesModal()">
                    ‚ùå No Thanks
                </button>
                <div id="purchaseStatus" style="margin-top: 10px;"></div>
            </div>
        </div>
        
        <div class="leaderboard-modal" id="leaderboardModal" style="display: none;">
            <div class="modal-content">
                <h3>üèÜ Leaderboard</h3>
                <div id="leaderboardContent">
                    <p>Loading leaderboard...</p>
                </div>
                <button class="btn" onclick="closeLeaderboard()">Close</button>
            </div>
        </div>
    </div>

    <!-- FARCASTER MINIAPP SDK INTEGRATION -->
    <script type="module">
        // üöÄ FARCASTER MINIAPP SDK INTEGRATION 2025
        console.log('üéÆ Lava Escape - Starting MiniApp initialization...');
        
        // Import MiniApp SDK
        import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
        
        // Global state
        let isInMiniApp = false;
        let readyCalled = false;
        let userContext = null;
        
        // Enable debug mode with ?debug=true
        const showDebug = window.location.search.includes('debug=true');
        if (showDebug) {
            document.getElementById('debugInfo').style.display = 'block';
        }
        
        function updateDebugStatus(elementId, status, isSuccess = true) {
            if (showDebug) {
                const el = document.getElementById(elementId);
                if (el) {
                    el.textContent = status;
                    el.style.color = isSuccess ? '#00ff88' : '#ff6b6b';
                }
            }
        }
        
        // Initialize MiniApp SDK
        async function initializeMiniApp() {
            try {
                console.log('üîÑ Initializing MiniApp SDK...');
                updateDebugStatus('sdkStatus', 'Loading MiniApp SDK...');
                
                // Check if we're in a mini app environment
                isInMiniApp = await sdk.isInMiniApp();
                console.log('üéØ Mini app status:', isInMiniApp);
                updateDebugStatus('envStatus', isInMiniApp ? 'Farcaster MiniApp' : 'Regular Browser');
                
                if (isInMiniApp) {
                    // Get user context
                    userContext = await sdk.context;
                    console.log('üë§ User context:', userContext);
                    updateDebugStatus('sdkStatus', 'MiniApp SDK Ready ‚úì');
                    
                    // Show Farcaster UI elements
                    const farcasterInfo = document.getElementById('farcasterInfo');
                    const socialActions = document.getElementById('socialActions');
                    
                    if (farcasterInfo) farcasterInfo.style.display = 'block';
                    if (socialActions) socialActions.style.display = 'block';
                    
                    // Update user info display
                    if (userContext?.user) {
                        const userInfo = document.getElementById('userInfo');
                        if (userInfo) {
                            const { user } = userContext;
                            userInfo.textContent = `Hey ${user.displayName || user.username || `FID ${user.fid}`}! üëã`;
                        }
                    }
                } else {
                    updateDebugStatus('sdkStatus', 'Browser Mode');
                }
                
                // Call ready() to dismiss splash screen
                await ensureReadyCalled();
                
            } catch (error) {
                console.error('‚ö†Ô∏è MiniApp SDK initialization failed:', error);
                updateDebugStatus('sdkStatus', 'SDK Failed', false);
                // Still call ready() even if initialization fails
                await ensureReadyCalled();
            }
        }
        
        // GUARANTEED ready() call
        async function ensureReadyCalled() {
            if (readyCalled) return;
            readyCalled = true;
            
            console.log('üöÄ Calling sdk.actions.ready()');
            updateDebugStatus('readyStatus', 'Called!', true);
            
            try {
                await sdk.actions.ready({
                    disableNativeGestures: false
                });
                console.log('‚úÖ ready() succeeded');
            } catch (error) {
                console.log('‚ö†Ô∏è ready() failed but that\'s OK:', error);
            }
        }
        
        // Social sharing functions
        window.shareScore = async function() {
            if (!isInMiniApp) {
                console.log('üì± Share feature only available in MiniApp');
                return;
            }
            
            try {
                const jumps = window.game?.jumps || 0;
                const level = window.game?.level || 1;
                const lives = window.gameState?.lives || 0;
                const emoji = jumps >= 50 ? 'üèÜ' : jumps >= 25 ? 'ü•á' : jumps >= 10 ? 'ü•à' : 'üî•';
                
                const text = `${emoji} Just escaped lava for ${jumps} jumps and reached level ${level} with ${lives} lives remaining! Can you beat my onchain score? üåã‚õìÔ∏è`;
                const embeds = ['https://lava-escape.netlify.app'];
                
                await sdk.actions.composeCast({
                    text,
                    embeds
                });
                
                console.log('‚úÖ Cast composed successfully');
            } catch (error) {
                console.error('‚ö†Ô∏è Failed to compose cast:', error);
            }
        };
        
        window.addToFarcaster = async function() {
            if (!isInMiniApp) {
                console.log('üì± Add to app feature only available in MiniApp');
                return;
            }
            
            try {
                await sdk.actions.addMiniApp();
                console.log('‚úÖ Add to app prompted');
            } catch (error) {
                console.error('‚ö†Ô∏è Failed to add to app:', error);
            }
        };
        
        // Make SDK available globally for wallet integration
        window.farcasterSDK = sdk;
        window.userContext = userContext;
        
        // Start initialization
        initializeMiniApp();
        
    </script>

    <!-- BASE L2 BLOCKCHAIN INTEGRATION -->
    <script type="module">
        // üîó BASE L2 BLOCKCHAIN INTEGRATION
        console.log('‚õìÔ∏è Initializing Base L2 integration...');
        
        // Import wagmi and viem
        import { createConfig, http, getAccount, readContract, writeContract, waitForTransactionReceipt } from 'https://esm.sh/@wagmi/core';
        import { base } from 'https://esm.sh/wagmi/chains';
        import { createPublicClient } from 'https://esm.sh/viem';
        
        // Smart contract addresses (will be updated after deployment)
        const CONTRACTS = {
            LIVES: '0x0000000000000000000000000000000000000000', // Placeholder
            LEADERBOARD: '0x0000000000000000000000000000000000000000', // Placeholder
            USDC: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' // Base USDC
        };
        
        // Contract ABIs (simplified for essential functions)
        const LIVES_ABI = [
            {
                "inputs": [{"name": "amount", "type": "uint8"}],
                "name": "buyLives",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [{"name": "player", "type": "address"}],
                "name": "getLives",
                "outputs": [{"name": "", "type": "uint8"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"name": "player", "type": "address"}],
                "name": "useLive",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];
        
        const LEADERBOARD_ABI = [
            {
                "inputs": [{"name": "jumps", "type": "uint256"}],
                "name": "submitScore",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getLeaderboard",
                "outputs": [{"components": [{"name": "player", "type": "address"}, {"name": "jumps", "type": "uint256"}, {"name": "timestamp", "type": "uint256"}], "name": "", "type": "tuple[]"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];
        
        // Configure wagmi for Base L2
        const config = createConfig({
            chains: [base],
            transports: {
                [base.id]: http(),
            },
        });
        
        // Global blockchain state
        let ethereumProvider = null;
        let userAddress = null;
        let userLives = 3; // Default lives
        
        // Initialize blockchain functionality
        async function initializeBlockchain() {
            try {
                // Get Ethereum provider from Farcaster SDK
                if (window.farcasterSDK && isInMiniApp) {
                    ethereumProvider = await window.farcasterSDK.wallet.getEthereumProvider();
                    console.log('üîó Ethereum provider obtained from Farcaster');
                    
                    // Get user address
                    const accounts = await ethereumProvider.request({
                        method: 'eth_accounts'
                    });
                    
                    if (accounts && accounts.length > 0) {
                        userAddress = accounts[0];
                        console.log('üëõ User address:', userAddress);
                        
                        // Load user's lives from contract
                        await loadUserLives();
                    }
                } else {
                    console.log('üåê No Farcaster wallet available, using browser mode');
                }
            } catch (error) {
                console.error('‚ö†Ô∏è Blockchain initialization failed:', error);
            }
        }
        
        // Load user's lives from smart contract
        async function loadUserLives() {
            if (!userAddress || CONTRACTS.LIVES === '0x0000000000000000000000000000000000000000') {
                console.log('üìù Contract not deployed yet, using default lives');
                return;
            }
            
            try {
                const lives = await readContract(config, {
                    address: CONTRACTS.LIVES,
                    abi: LIVES_ABI,
                    functionName: 'getLives',
                    args: [userAddress],
                });
                
                userLives = parseInt(lives.toString());
                console.log('‚ù§Ô∏è User lives loaded:', userLives);
                updateLivesDisplay();
            } catch (error) {
                console.error('‚ö†Ô∏è Failed to load lives:', error);
                userLives = 3; // Default fallback
            }
        }
        
        // Buy lives with ETH
        async function buyLives(amount = 1) {
            if (!ethereumProvider || !userAddress || CONTRACTS.LIVES === '0x0000000000000000000000000000000000000000') {
                console.log('‚ö†Ô∏è Blockchain not available for purchase');
                return false;
            }
            
            try {
                const pricePerLife = '100000000000000'; // 0.0001 ETH in wei
                const totalPrice = (BigInt(pricePerLife) * BigInt(amount)).toString();
                
                const hash = await writeContract(config, {
                    address: CONTRACTS.LIVES,
                    abi: LIVES_ABI,
                    functionName: 'buyLives',
                    args: [amount],
                    value: totalPrice,
                });
                
                console.log('‚è≥ Transaction submitted:', hash);
                
                // Wait for confirmation
                await waitForTransactionReceipt(config, { hash });
                
                console.log('‚úÖ Lives purchased successfully!');
                await loadUserLives(); // Refresh lives count
                return true;
            } catch (error) {
                console.error('‚ö†Ô∏è Failed to buy lives:', error);
                
                // Show user-friendly error message
                let errorMessage = 'Failed to purchase lives. ';
                if (error.message?.includes('insufficient funds')) {
                    errorMessage += 'Insufficient ETH balance.';
                } else if (error.message?.includes('user rejected')) {
                    errorMessage += 'Transaction was cancelled.';
                } else if (error.message?.includes('Would exceed max lives')) {
                    errorMessage += 'Would exceed maximum lives (255).';
                } else {
                    errorMessage += 'Please try again.';
                }
                
                alert(errorMessage);
                return false;
            }
        }
        
        // Use a life (called when game over)
        async function useLive() {
            if (!ethereumProvider || !userAddress || CONTRACTS.LIVES === '0x0000000000000000000000000000000000000000') {
                // Offline mode - just decrement locally
                if (userLives > 0) {
                    userLives--;
                    updateLivesDisplay();
                    return true;
                }
                return false;
            }
            
            try {
                const hash = await writeContract(config, {
                    address: CONTRACTS.LIVES,
                    abi: LIVES_ABI,
                    functionName: 'useLive',
                    args: [userAddress],
                });
                
                await waitForTransactionReceipt(config, { hash });
                await loadUserLives(); // Refresh lives count
                return true;
            } catch (error) {
                console.error('‚ö†Ô∏è Failed to use life:', error);
                // Fallback to local decrement
                if (userLives > 0) {
                    userLives--;
                    updateLivesDisplay();
                    return true;
                }
                return false;
            }
        }
        
        // Submit score to leaderboard
        async function submitScore(jumps, level) {
            if (!ethereumProvider || !userAddress || CONTRACTS.LEADERBOARD === '0x0000000000000000000000000000000000000000') {
                console.log('üìä Leaderboard contract not available');
                return false;
            }
            
            try {
                const hash = await writeContract(config, {
                    address: CONTRACTS.LEADERBOARD,
                    abi: LEADERBOARD_ABI,
                    functionName: 'submitScore',
                    args: [jumps, level || 1],
                });
                
                await waitForTransactionReceipt(config, { hash });
                console.log('‚úÖ Score submitted to leaderboard!');
                return true;
            } catch (error) {
                console.error('‚ö†Ô∏è Failed to submit score:', error);
                return false;
            }
        }
        
        // Get leaderboard data
        async function getLeaderboard() {
            if (CONTRACTS.LEADERBOARD === '0x0000000000000000000000000000000000000000') {
                // Return mock data for testing
                return [
                    { player: '0x1234...5678', jumps: 125, timestamp: Date.now(), level: 8 },
                    { player: '0x9876...4321', jumps: 98, timestamp: Date.now(), level: 6 },
                    { player: '0xabcd...ef01', jumps: 87, timestamp: Date.now(), level: 5 }
                ];
            }
            
            try {
                const leaderboard = await readContract(config, {
                    address: CONTRACTS.LEADERBOARD,
                    abi: LEADERBOARD_ABI,
                    functionName: 'getLeaderboard',
                });
                
                return leaderboard;
            } catch (error) {
                console.error('‚ö†Ô∏è Failed to get leaderboard:', error);
                return [];
            }
        }
        
        // Update lives display in UI
        function updateLivesDisplay() {
            const livesElement = document.getElementById('lives');
            if (livesElement) {
                livesElement.textContent = userLives;
            }
        }
        
        // Make functions globally available
        window.blockchain = {
            initializeBlockchain,
            loadUserLives,
            buyLives,
            useLive,
            submitScore,
            getLeaderboard,
            getUserLives: () => userLives,
            getUserAddress: () => userAddress,
            isWalletConnected: () => !!userAddress
        };
        
        // Initialize after a short delay to ensure Farcaster SDK is ready
        setTimeout(initializeBlockchain, 2000);
        
    </script>

    <!-- ORIGINAL GAME CODE - UNCHANGED -->
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let game = {
            jumps: 0,
            level: 1,
            lavaSpeed: 0.5,
            lavaHeight: 0,
            running: false,
            introStep: 0,
            keys: {},
            gameStarted: false,
            cameraY: 0,
            highestPlayerY: 460,
            deathReason: "burned",
            deathTimer: 0,
            dyingState: false,
            levelNotification: {
                show: false,
                level: 1,
                timer: 0
            }
        };
        
        // Make game globally accessible for sharing
        window.game = game;
        
        // Player
        let player = {
            x: 180,
            y: 460,
            width: 8,
            height: 16,
            velocityX: 0,
            velocityY: 0,
            onGround: true,
            jumpPower: -15,
            speed: 5,
            hasJumped: false
        };
        
        // Platforms
        let platforms = [];
        let highestPlatform = 480;
        
        // Intro sequence
        let introMessages = [
            "Everything seems normal...",
            "Wait... do you feel that rumbling? ü§î",
            "OH NO! LAVA IS RISING! üåã",
            "JUMP TO SAVE YOUR LIFE! ‚¨ÜÔ∏è"
        ];
        
        function nextIntroStep() {
            game.introStep++;
            
            if (game.introStep < introMessages.length) {
                document.getElementById('introText').textContent = introMessages[game.introStep];
                if (game.introStep === introMessages.length - 1) {
                    document.getElementById('continueBtn').textContent = "START JUMPING!";
                    document.getElementById('continueBtn').className = "btn danger-btn";
                }
            } else {
                startGame();
            }
        }
        
        function startGame() {
            // Check if player can start
            if (!canStartGame()) {
                document.getElementById('introText').textContent = "‚ùå No lives remaining! Purchase more lives to continue.";
                document.getElementById('continueBtn').textContent = "Buy Lives";
                document.getElementById('continueBtn').onclick = showBuyLivesModal;
                return;
            }
            
            document.getElementById('introScreen').style.display = 'none';
            game.running = true;
            game.gameStarted = true;
            generateInitialPlatforms();
            initializeLivesDisplay();
        }
        
        function generateInitialPlatforms() {
            platforms = [];
            
            // Starting ground platform
            platforms.push({x: 0, y: 480, width: 360, height: 20, type: 'ground'});
            
            // Generate platforms going up
            for (let i = 1; i <= 20; i++) {
                let width = 80 + Math.random() * 100;
                let x = Math.random() * (360 - width);
                let y = 480 - (i * 70);
                
                platforms.push({
                    x: x,
                    y: y,
                    width: width,
                    height: 12,
                    type: 'platform'
                });
                
                highestPlatform = y;
            }
        }
        
        function generateMorePlatforms() {
            for (let i = 0; i < 5; i++) {
                let width = 80 + Math.random() * 100;
                let x = Math.random() * (360 - width);
                highestPlatform -= 70;
                
                platforms.push({
                    x: x,
                    y: highestPlatform,
                    width: width,
                    height: 12,
                    type: 'platform'
                });
            }
        }
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            game.keys[e.code] = true;
        });
        
        document.addEventListener('keyup', (e) => {
            game.keys[e.code] = false;
        });
        
        // Mobile/click controls
        canvas.addEventListener('click', (e) => {
            if (game.running && player.onGround) {
                player.velocityY = player.jumpPower;
                player.onGround = false;
                player.hasJumped = true;
            }
        });
        
        function updatePlayer() {
            if (!game.running) return;
            
            // Handle input
            if (game.keys['ArrowLeft'] || game.keys['KeyA']) {
                player.velocityX = -player.speed;
            } else if (game.keys['ArrowRight'] || game.keys['KeyD']) {
                player.velocityX = player.speed;
            } else {
                player.velocityX *= 0.8; // Friction
            }
            
            if ((game.keys['Space'] || game.keys['ArrowUp'] || game.keys['KeyW']) && player.onGround) {
                player.velocityY = player.jumpPower;
                player.onGround = false;
                player.hasJumped = true;
            }
            
            // Apply gravity
            player.velocityY += 0.8;
            
            // Update position
            player.x += player.velocityX;
            player.y += player.velocityY;
            
            // Screen wrapping
            if (player.x < 0) player.x = canvas.width - player.width;
            if (player.x > canvas.width) player.x = 0;
            
            // Check platform collisions
            let wasOnGround = player.onGround;
            player.onGround = false;
            
            for (let platform of platforms) {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {
                    
                    if (player.velocityY > 0 && player.y + player.height - player.velocityY <= platform.y + 5) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        
                        if (!wasOnGround && player.hasJumped) {
                            game.jumps++;
                            player.hasJumped = false;
                            checkLevelUp();
                        }
                        break;
                    }
                }
            }
            
            if (player.y < highestPlatform + 200) {
                generateMorePlatforms();
            }
        }
        
        function checkLevelUp() {
            let newLevel = Math.floor(game.jumps / 15) + 1;
            if (newLevel > game.level) {
                game.level = newLevel;
                game.lavaSpeed += 0.3;
                
                game.levelNotification.show = true;
                game.levelNotification.level = newLevel;
                game.levelNotification.timer = 120;
            }
        }
        
        function updateCamera() {
            if (player.y < game.highestPlayerY) {
                game.highestPlayerY = player.y;
            }
            
            let targetCameraY = game.highestPlayerY - 200;
            game.cameraY = Math.min(game.cameraY, targetCameraY);
        }
        
        function updateLevelNotification() {
            if (game.levelNotification.show) {
                game.levelNotification.timer--;
                if (game.levelNotification.timer <= 0) {
                    game.levelNotification.show = false;
                }
            }
        }
        
        function updateLava() {
            if (!game.running) return;
            
            game.lavaHeight += game.lavaSpeed;
            
            let lavaWorldY = 500 - game.lavaHeight;
            if (player.y + player.height >= lavaWorldY) {
                game.deathReason = "burned";
                gameOver();
                return;
            }
            
            let playerScreenY = player.y - game.cameraY;
            if (playerScreenY > canvas.height + 50) {
                if (!game.dyingState) {
                    game.dyingState = true;
                    game.deathTimer = 120;
                    
                    let lavaScreenY = lavaWorldY - game.cameraY;
                    if (lavaScreenY < canvas.height) {
                        game.deathReason = "fell";
                    } else {
                        game.deathReason = "offscreen";
                    }
                }
            }
            
            if (game.dyingState) {
                game.deathTimer--;
                if (game.deathTimer <= 0) {
                    gameOver();
                }
            }
        }
        
        function drawStickman(x, y) {
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            
            // Head
            ctx.beginPath();
            ctx.arc(x + 4, y + 3, 3, 0, Math.PI * 2);
            ctx.stroke();
            
            // Body
            ctx.beginPath();
            ctx.moveTo(x + 4, y + 6);
            ctx.lineTo(x + 4, y + 12);
            ctx.stroke();
            
            // Arms
            ctx.beginPath();
            if (!player.onGround) {
                ctx.moveTo(x + 4, y + 8);
                ctx.lineTo(x + 1, y + 5);
                ctx.moveTo(x + 4, y + 8);
                ctx.lineTo(x + 7, y + 5);
            } else {
                ctx.moveTo(x + 1, y + 8);
                ctx.lineTo(x + 7, y + 8);
            }
            ctx.stroke();
            
            // Legs
            ctx.beginPath();
            ctx.moveTo(x + 4, y + 12);
            ctx.lineTo(x + 1, y + 16);
            ctx.moveTo(x + 4, y + 12);
            ctx.lineTo(x + 7, y + 16);
            ctx.stroke();
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw platforms
            for (let platform of platforms) {
                let drawY = platform.y - game.cameraY;
                
                if (drawY > -20 && drawY < canvas.height + 20) {
                    if (platform.type === 'ground') {
                        ctx.fillStyle = '#8B4513';
                    } else {
                        ctx.fillStyle = '#228B22';
                    }
                    
                    ctx.fillRect(platform.x, drawY, platform.width, platform.height);
                    
                    ctx.fillStyle = '#32CD32';
                    ctx.fillRect(platform.x, drawY, platform.width, 2);
                }
            }
            
            // Draw player
            let playerDrawY = player.y - game.cameraY;
            if (playerDrawY <= canvas.height + 50) {
                drawStickman(player.x, playerDrawY);
            }
            
            // Draw lava
            if (game.lavaHeight > 0) {
                let lavaWorldY = 500 - game.lavaHeight;
                let lavaScreenY = lavaWorldY - game.cameraY;
                
                if (lavaScreenY < canvas.height) {
                    let visibleLavaHeight = canvas.height - Math.max(0, lavaScreenY);
                    let drawStartY = Math.max(0, lavaScreenY);
                    
                    let gradient = ctx.createLinearGradient(0, drawStartY, 0, canvas.height);
                    gradient.addColorStop(0, '#ff6b6b');
                    gradient.addColorStop(0.5, '#ff4757');
                    gradient.addColorStop(1, '#ff3742');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, drawStartY, canvas.width, visibleLavaHeight);
                    
                    // Lava bubbles
                    ctx.fillStyle = '#ffda79';
                    for (let i = 0; i < 10; i++) {
                        let bubbleX = Math.random() * canvas.width;
                        let bubbleY = drawStartY + Math.random() * Math.min(visibleLavaHeight, 50);
                        let size = 2 + Math.random() * 4;
                        
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    if (lavaScreenY > -50 && lavaScreenY < canvas.height - 50) {
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 12px Courier New';
                        ctx.textAlign = 'center';
                        ctx.fillText('üî• LAVA RISING! üî•', canvas.width/2, Math.max(20, lavaScreenY - 10));
                    }
                }
            }
            
            // Death countdown
            if (game.dyingState) {
                let countdown = Math.ceil(game.deathTimer / 60);
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(`üíÄ ${countdown}`, canvas.width/2, canvas.height/2);
                
                ctx.font = 'bold 12px Courier New';
                ctx.fillText('Fell off screen!', canvas.width/2, canvas.height/2 + 30);
            }
            
            // Level up notification
            if (game.levelNotification.show) {
                let opacity = game.levelNotification.timer / 120;
                
                ctx.fillStyle = `rgba(0, 255, 136, ${opacity * 0.4})`;
                ctx.fillRect(0, 100, canvas.width, 80);
                
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.font = 'bold 18px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('üéâ LEVEL UP! üéâ', canvas.width/2, 130);
                
                ctx.font = 'bold 14px Courier New';
                ctx.fillText(`REACHED LEVEL ${game.levelNotification.level}`, canvas.width/2, 150);
            }
        }
        
        function updateUI() {
            document.getElementById('jumps').textContent = game.jumps;
            document.getElementById('level').textContent = game.level;
            document.getElementById('speed').textContent = game.lavaSpeed.toFixed(1) + 'x';
        }
        
        async function gameOver() {
            game.running = false;
            game.dyingState = false;
            
            // Use a life
            let canContinue = false;
            if (window.blockchain) {
                canContinue = await window.blockchain.useLive();
            }
            
            if (!canContinue) {
                // No lives left - show game over
                if (game.deathReason === "fell") {
                    document.getElementById('gameOverTitle').textContent = "üíÄ NO LIVES LEFT!";
                    document.getElementById('gameOverMessage').textContent = "You fell into lava and ran out of lives!";
                } else if (game.deathReason === "offscreen") {
                    document.getElementById('gameOverTitle').textContent = "üíÄ NO LIVES LEFT!";
                    document.getElementById('gameOverMessage').textContent = "You fell too far and ran out of lives!";
                } else {
                    document.getElementById('gameOverTitle').textContent = "üî• NO LIVES LEFT!";
                    document.getElementById('gameOverMessage').textContent = "The lava caught you and you're out of lives!";
                }
                
                document.getElementById('finalJumps').textContent = game.jumps;
                document.getElementById('finalLevel').textContent = game.level;
                
                // Try to submit score to leaderboard
                if (window.blockchain && game.jumps >= 5) {
                    try {
                        await window.blockchain.submitScore(game.jumps, game.level);
                    } catch (error) {
                        console.log('Failed to submit score:', error);
                    }
                }
                
                document.getElementById('gameOver').style.display = 'block';
                
                // Show buy lives option if user has wallet connected
                if (window.blockchain && window.blockchain.isWalletConnected()) {
                    showBuyLivesModal();
                }
            } else {
                // Still have lives - quick restart
                console.log('‚ù§Ô∏è Life used, restarting quickly...');
                setTimeout(() => {
                    restartGame();
                }, 1000);
            }
        }
        
        function restartGame() {
            game = {
                jumps: 0,
                level: 1,
                lavaSpeed: 0.5,
                lavaHeight: 0,
                running: false,
                introStep: 0,
                keys: {},
                gameStarted: false,
                cameraY: 0,
                highestPlayerY: 460,
                deathReason: "burned",
                deathTimer: 0,
                dyingState: false,
                levelNotification: {
                    show: false,
                    level: 1,
                    timer: 0
                }
            };
            
            window.game = game; // Update global reference
            
            player = {
                x: 180,
                y: 460,
                width: 8,
                height: 16,
                velocityX: 0,
                velocityY: 0,
                onGround: true,
                jumpPower: -15,
                speed: 5,
                hasJumped: false
            };
            
            platforms = [];
            highestPlatform = 480;
            
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('introScreen').style.display = 'block';
            document.getElementById('introText').textContent = introMessages[0];
            document.getElementById('continueBtn').textContent = "Continue";
            document.getElementById('continueBtn').className = "btn";
        }
        
        function gameLoop() {
            updatePlayer();
            updateCamera();
            updateLevelNotification();
            updateLava();
            draw();
            updateUI();
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize game
        generateInitialPlatforms();
        gameLoop();
        
        // Buy Lives Modal Functions
        function showBuyLivesModal() {
            document.getElementById('buyLivesModal').style.display = 'flex';
        }
        
        function closeBuyLivesModal() {
            document.getElementById('buyLivesModal').style.display = 'none';
        }
        
        async function buyLivesWithETH(amount) {
            const statusEl = document.getElementById('purchaseStatus');
            statusEl.innerHTML = '‚è≥ Processing ETH purchase...';
            
            try {
                const success = await window.blockchain.buyLives(amount);
                if (success) {
                    statusEl.innerHTML = '‚úÖ Lives purchased! Restarting game...';
                    setTimeout(() => {
                        closeBuyLivesModal();
                        restartGame();
                    }, 2000);
                } else {
                    statusEl.innerHTML = '‚ùå Purchase failed. Please try again.';
                }
            } catch (error) {
                console.error('Purchase failed:', error);
                statusEl.innerHTML = '‚ùå Purchase failed. Check console for details.';
            }
        }
        
        async function buyLivesWithUSDC(amount) {
            const statusEl = document.getElementById('purchaseStatus');
            statusEl.innerHTML = '‚è≥ Processing USDC purchase...';
            
            try {
                // This would need USDC approval first in a real implementation
                statusEl.innerHTML = '‚ùå USDC purchases not yet implemented.';
            } catch (error) {
                console.error('USDC Purchase failed:', error);
                statusEl.innerHTML = '‚ùå Purchase failed. Check console for details.';
            }
        }
        
        // Initialize lives display when game starts
        function initializeLivesDisplay() {
            if (window.blockchain) {
                const lives = window.blockchain.getUserLives();
                const livesEl = document.getElementById('lives');
                if (livesEl) {
                    livesEl.textContent = lives;
                }
            }
        }
        
        // Check if player can start game
        function canStartGame() {
            if (!window.blockchain) {
                return true; // Browser mode - always allow
            }
            
            const lives = window.blockchain.getUserLives();
            return lives > 0;
        }
        
        // Leaderboard Functions
        async function showLeaderboard() {
            const modal = document.getElementById('leaderboardModal');
            const content = document.getElementById('leaderboardContent');
            
            modal.style.display = 'flex';
            content.innerHTML = '<p>Loading leaderboard...</p>';
            
            try {
                const leaderboard = await window.blockchain.getLeaderboard();
                
                if (leaderboard.length === 0) {
                    content.innerHTML = '<p>No scores yet. Be the first to set a record!</p>';
                    return;
                }
                
                let html = '';
                leaderboard.forEach((entry, index) => {
                    const rank = index + 1;
                    const address = typeof entry.player === 'string' ? 
                        entry.player.slice(0, 6) + '...' + entry.player.slice(-4) :
                        'Unknown';
                    const jumps = parseInt(entry.jumps);
                    const level = parseInt(entry.level || 1);
                    
                    const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : 'üèÖ';
                    
                    html += `
                        <div class="leaderboard-entry">
                            <span class="player-rank">${medal} ${rank}</span>
                            <div>
                                <div class="player-address">${address}</div>
                                <div>Level ${level}</div>
                            </div>
                            <span class="player-score">${jumps} jumps</span>
                        </div>
                    `;
                });
                
                content.innerHTML = html;
                
            } catch (error) {
                console.error('Failed to load leaderboard:', error);
                content.innerHTML = '<p>Failed to load leaderboard. Try again later.</p>';
            }
        }
        
        function closeLeaderboard() {
            document.getElementById('leaderboardModal').style.display = 'none';
        }
        
        console.log('üéÆ Game initialized successfully');
    </script>
</body>
</html>