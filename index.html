<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lava Escape</title>
    
    <!-- Farcaster Mini App Meta Tags - 2025 -->
    <meta name="fc:miniapp" content='{"version":"1","imageUrl":"https://lava-escape.netlify.app/splash.png","button":{"title":"üåã Escape the Lava","action":{"type":"launch_frame","name":"üåã Lava Escape","url":"https://lava-escape.netlify.app","splashImageUrl":"https://lava-escape.netlify.app/splash.png","splashBackgroundColor":"#1a1a2e"}}}' />
    <!-- Backward compatibility -->
    <meta name="fc:frame" content='{"version":"1","imageUrl":"https://lava-escape.netlify.app/splash.png","button":{"title":"üåã Escape the Lava","action":{"type":"launch_frame","name":"üåã Lava Escape","url":"https://lava-escape.netlify.app","splashImageUrl":"https://lava-escape.netlify.app/splash.png","splashBackgroundColor":"#1a1a2e"}}}' />
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="üåã Lava Escape - Jump to Survive!" />
    <meta property="og:description" content="Help the stickman escape rising lava! Jump between platforms with onchain lives and compete on the Base L2 leaderboard." />
    <meta property="og:image" content="https://lava-escape.netlify.app/splash.png" />
    <meta property="og:url" content="https://lava-escape.netlify.app" />
    <meta property="og:type" content="website" />
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .game-container {
            background: #1a1a2e;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 400px;
            width: 100%;
        }
        
        .game-header {
            text-align: center;
            color: #fff;
            margin-bottom: 15px;
        }
        
        .stats {
            display: flex;
            justify-content: space-between;
            color: #00ff88;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .farcaster-info {
            display: none;
            text-align: center;
            color: #00ff88;
            font-size: 12px;
            margin-bottom: 10px;
            padding: 5px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 5px;
        }
        
        canvas {
            border: 2px solid #00ff88;
            border-radius: 5px;
            display: block;
            margin: 0 auto;
            background: linear-gradient(180deg, #87CEEB 0%, #98FB98 100%);
        }
        
        .controls {
            text-align: center;
            color: #fff;
            font-size: 12px;
            margin-top: 10px;
        }
        
        .social-actions {
            display: none;
            text-align: center;
            margin-top: 10px;
        }
        
        .social-btn {
            background: #8a63d2;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            margin: 0 5px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        
        .social-btn:hover {
            background: #7a53c2;
        }
        
        .social-btn.primary {
            background: #00ff88;
            color: #000;
        }
        
        .social-btn.primary:hover {
            background: #00cc6a;
        }
        
        .intro-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            color: #fff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #ff6b6b;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        
        .btn {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
        }
        
        .btn:hover {
            background: #00cc6a;
        }
        
        .danger-btn {
            background: #ff6b6b;
            color: #fff;
        }
        
        .danger-btn:hover {
            background: #ff5252;
        }

        .debug-info {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
            padding: 5px;
            background: rgba(0,0,0,0.3);
            border-radius: 3px;
        }
        
        .modal-content {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #00ff88;
            text-align: center;
            color: #fff;
            max-width: 400px;
            width: 90%;
        }
        
        .leaderboard-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .leaderboard-modal .modal-content {
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 5px;
            font-size: 12px;
        }
        
        .leaderboard-entry:nth-child(1) { background: rgba(255, 215, 0, 0.3); } /* Gold */
        .leaderboard-entry:nth-child(2) { background: rgba(192, 192, 192, 0.3); } /* Silver */
        .leaderboard-entry:nth-child(3) { background: rgba(205, 127, 50, 0.3); } /* Bronze */
        
        .player-rank {
            font-weight: bold;
            width: 30px;
        }
        
        .player-address {
            font-family: monospace;
            font-size: 10px;
            opacity: 0.8;
        }
        
        .player-score {
            font-weight: bold;
            color: #00ff88;
        }
        
        /* Mobile touch zone indicators */
        .touch-hints {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .touch-hints.visible {
            opacity: 0.6;
        }
        
        .touch-zone-indicator {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.7);
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        
        .touch-zone-left {
            left: 5%;
            top: 60%;
            width: 40%;
            height: 25%;
        }
        
        .touch-zone-right {
            right: 5%;
            top: 60%;
            width: 40%;
            height: 25%;
        }
        
        /* Mobile-specific control text */
        .mobile-controls {
            display: none;
            text-align: center;
            color: #888;
            font-size: 10px;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .controls {
                display: none;
            }
            .mobile-controls {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h2>üåã LAVA ESCAPE</h2>
            <div class="farcaster-info" id="farcasterInfo">
                <span id="userInfo">Playing in Farcaster!</span>
            </div>
            <div class="stats">
                <span>‚ù§Ô∏è Lives: <span id="lives">3</span></span>
                <span>Jumps: <span id="jumps">0</span></span>
                <span>Level: <span id="level">1</span></span>
                <span>Speed: <span id="speed">1.0x</span></span>
            </div>
        </div>
        
        <div style="position: relative;">
            <canvas id="gameCanvas" width="360" height="500"></canvas>
            
            <!-- Touch zone visual indicators (mobile only) -->
            <div id="touchHints" class="touch-hints">
                <div class="touch-zone-indicator touch-zone-left">
                    üëà MOVE + TAP
                </div>
                <div class="touch-zone-indicator touch-zone-right">
                    MOVE + TAP üëâ
                </div>
            </div>
        </div>
        
        <div class="controls">
            üéÆ Arrow Keys/WASD ‚Ä¢ Space/Click to jump ‚Ä¢ ESCAPE THE LAVA!
        </div>
        <div class="mobile-controls">
            üì± Tap screen to jump ‚Ä¢ Hold left/right sides to move ‚Ä¢ ESCAPE THE LAVA!
            <div id="debugInfo" class="debug-info" style="display: none;">
                <div>Environment: <span id="envStatus">Checking...</span></div>
                <div>SDK Status: <span id="sdkStatus">Loading...</span></div>
                <div>Ready Called: <span id="readyStatus">Not yet</span></div>
            </div>
        </div>
        
        <div class="social-actions" id="socialActions">
            <button class="social-btn primary" id="shareScore" onclick="shareScore()">üìä Share Score</button>
            <button class="social-btn" id="addToApp" onclick="addToFarcaster()">‚ûï Add to App</button>
            <button class="social-btn" id="showLeaderboard" onclick="showLeaderboard()">üèÜ Leaderboard</button>
        </div>
        
        <div class="intro-screen" id="introScreen">
            <h3>ü§î Hey... what's happening?</h3>
            <p id="introText">Everything seems normal...</p>
            <button class="btn" id="continueBtn" onclick="nextIntroStep()">Continue</button>
        </div>
        
        <div class="game-over" id="gameOver">
            <h3 id="gameOverTitle">üî• BURNED BY LAVA!</h3>
            <p id="gameOverMessage">You couldn't escape in time!</p>
            <p>Final Jumps: <span id="finalJumps">0</span></p>
            <p>Level Reached: <span id="finalLevel">1</span></p>
            <button class="btn" onclick="restartGame()">üîÑ Try Again</button>
        </div>
        
        
        <div class="leaderboard-modal" id="leaderboardModal" style="display: none;">
            <div class="modal-content">
                <h3>üèÜ Leaderboard</h3>
                <div id="leaderboardContent">
                    <p>Loading leaderboard...</p>
                </div>
                <button class="btn" onclick="closeLeaderboard()">Close</button>
            </div>
        </div>
    </div>

    <!-- FARCASTER MINIAPP SDK INTEGRATION -->

    <script>
        // üí∞ GLOBAL PRICING CONFIGURATION
        // Make pricing constants globally available for all functions
        window.PRICING = {
            USD_PER_LIFE: 0.30,           // $0.30 per life
            ETH_PER_LIFE: '100000000000000',  // 0.0001 ETH in wei
            USDC_PER_LIFE: 300000,        // 0.30 USDC (6 decimals: 300,000 units)
            USDC_TESTNET: '0x036CbD53842c5426634e7929541eC2318f3dCF7e', // Base Sepolia USDC
            USDC_MAINNET: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'  // Base Mainnet USDC
        };
    </script>

    <script type="module">
        // üöÄ FARCASTER MINIAPP SDK INTEGRATION 2025
        console.log('üéÆ Lava Escape - Starting MiniApp initialization...');
        
        // Import MiniApp SDK
        import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
        
        // Global state
        window.window.isInMiniApp = false;
        let readyCalled = false;
        let userContext = null;
        
        // Enable debug mode with ?debug=true
        const showDebug = window.location.search.includes('debug=true');
        if (showDebug) {
            document.getElementById('debugInfo').style.display = 'block';
        }
        
        function updateDebugStatus(elementId, status, isSuccess = true) {
            if (showDebug) {
                const el = document.getElementById(elementId);
                if (el) {
                    el.textContent = status;
                    el.style.color = isSuccess ? '#00ff88' : '#ff6b6b';
                }
            }
        }
        
        // Initialize MiniApp SDK
        async function initializeMiniApp() {
            try {
                console.log('üîÑ Initializing MiniApp SDK...');
                updateDebugStatus('sdkStatus', 'Loading MiniApp SDK...');
                
                // Check if we're in a mini app environment
                window.window.isInMiniApp = await sdk.window.isInMiniApp();
                console.log('üéØ Mini app status:', window.window.isInMiniApp);
                updateDebugStatus('envStatus', window.window.isInMiniApp ? 'Farcaster MiniApp' : 'Regular Browser');
                
                if (window.isInMiniApp) {
                    // Get user context
                    userContext = await sdk.context;
                    console.log('üë§ User context:', userContext);
                    updateDebugStatus('sdkStatus', 'MiniApp SDK Ready ‚úì');
                    
                    // Show Farcaster UI elements
                    const farcasterInfo = document.getElementById('farcasterInfo');
                    const socialActions = document.getElementById('socialActions');
                    
                    if (farcasterInfo) farcasterInfo.style.display = 'block';
                    if (socialActions) socialActions.style.display = 'block';
                    
                    // Update user info display
                    if (userContext?.user) {
                        const userInfo = document.getElementById('userInfo');
                        if (userInfo) {
                            const { user } = userContext;
                            userInfo.textContent = `Hey ${user.displayName || user.username || `FID ${user.fid}`}! üëã`;
                        }
                    }
                } else {
                    updateDebugStatus('sdkStatus', 'Browser Mode');
                }
                
                // Call ready() to dismiss splash screen
                await ensureReadyCalled();
                
            } catch (error) {
                console.error('‚ö†Ô∏è MiniApp SDK initialization failed:', error);
                updateDebugStatus('sdkStatus', 'SDK Failed', false);
                // Still call ready() even if initialization fails
                await ensureReadyCalled();
            }
        }
        
        // GUARANTEED ready() call
        async function ensureReadyCalled() {
            if (readyCalled) return;
            readyCalled = true;
            
            console.log('üöÄ Calling sdk.actions.ready()');
            updateDebugStatus('readyStatus', 'Called!', true);
            
            try {
                await sdk.actions.ready({
                    disableNativeGestures: false
                });
                console.log('‚úÖ ready() succeeded');
            } catch (error) {
                console.log('‚ö†Ô∏è ready() failed but that\'s OK:', error);
            }
        }
        
        // Social sharing functions
        window.shareScore = async function() {
            if (!window.isInMiniApp) {
                console.log('üì± Share feature only available in MiniApp');
                return;
            }
            
            try {
                const jumps = window.game?.jumps || 0;
                const level = window.game?.level || 1;
                const lives = window.gameState?.lives || 0;
                const emoji = jumps >= 50 ? 'üèÜ' : jumps >= 25 ? 'ü•á' : jumps >= 10 ? 'ü•à' : 'üî•';
                
                const text = `${emoji} Just escaped lava for ${jumps} jumps and reached level ${level} with ${lives} lives remaining! Can you beat my onchain score? üåã‚õìÔ∏è`;
                const embeds = ['https://lava-escape.netlify.app'];
                
                await sdk.actions.composeCast({
                    text,
                    embeds
                });
                
                console.log('‚úÖ Cast composed successfully');
            } catch (error) {
                console.error('‚ö†Ô∏è Failed to compose cast:', error);
            }
        };
        
        window.addToFarcaster = async function() {
            if (!window.isInMiniApp) {
                console.log('üì± Add to app feature only available in MiniApp');
                return;
            }
            
            try {
                await sdk.actions.addMiniApp();
                console.log('‚úÖ Add to app prompted');
            } catch (error) {
                console.error('‚ö†Ô∏è Failed to add to app:', error);
            }
        };
        
        // Make SDK available globally for wallet integration
        window.farcasterSDK = sdk;
        window.userContext = userContext;
        
        // Start initialization
        initializeMiniApp();
        
    </script>

    <!-- SIMPLE GAME STATE MANAGEMENT -->
    <script>
        // Simple lives management - no blockchain complexity
        let userLives = 3; // Default lives for browser mode
        
        // Update lives display in UI
        function updateLivesDisplay() {
            const livesElement = document.getElementById('lives');
            if (livesElement) {
                livesElement.textContent = userLives;
            }
        }
        
        // Use a life (called when game over)
        function useLive() {
            if (userLives > 0) {
                userLives--;
                updateLivesDisplay();
                return true;
            }
            return false;
        }
        
        // Simple leaderboard mock data
        async function getLeaderboard() {
            return [
                { player: '0x1234...5678', jumps: 125, timestamp: Date.now(), level: 8 },
                { player: '0x9876...4321', jumps: 98, timestamp: Date.now(), level: 6 },
                { player: '0xabcd...ef01', jumps: 87, timestamp: Date.now(), level: 5 }
            ];
        }
        
        // Make functions globally available
        window.updateLivesDisplay = updateLivesDisplay;
        window.getLeaderboard = getLeaderboard;
        
    </script>

    <!-- ORIGINAL GAME CODE - UNCHANGED -->
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let game = {
            jumps: 0,
            level: 1,
            lavaSpeed: 0.5,
            lavaHeight: 0,
            running: false,
            introStep: 0,
            keys: {},
            gameStarted: false,
            cameraY: 0,
            highestPlayerY: 460,
            deathReason: "burned",
            deathTimer: 0,
            dyingState: false,
            firstTimePlayer: true, // Track if this is the first time playing
            levelNotification: {
                show: false,
                level: 1,
                timer: 0
            }
        };
        
        // Make game globally accessible for sharing
        window.game = game;
        
        // Player
        let player = {
            x: 180,
            y: 460,
            width: 8,
            height: 16,
            velocityX: 0,
            velocityY: 0,
            onGround: true,
            jumpPower: -15,
            speed: 5,
            hasJumped: false
        };
        
        // Platforms
        let platforms = [];
        let highestPlatform = 480;
        
        // Intro sequence
        let introMessages = [
            "Everything seems normal...",
            "Wait... do you feel that rumbling? ü§î",
            "OH NO! LAVA IS RISING! üåã",
            "JUMP TO SAVE YOUR LIFE! ‚¨ÜÔ∏è"
        ];
        
        function nextIntroStep() {
            game.introStep++;
            
            if (game.introStep < introMessages.length) {
                document.getElementById('introText').textContent = introMessages[game.introStep];
                if (game.introStep === introMessages.length - 1) {
                    document.getElementById('continueBtn').textContent = "START JUMPING!";
                    document.getElementById('continueBtn').className = "btn danger-btn";
                }
            } else {
                startGame();
            }
        }
        
        function startGame() {
            // Check if player can start
            if (!canStartGame()) {
                document.getElementById('introText').textContent = "‚ùå No lives remaining! Restart the game to get new lives.";
                document.getElementById('continueBtn').textContent = "Restart Game";
                document.getElementById('continueBtn').onclick = restartGame;
                return;
            }
            
            // Mark that the player is no longer first-time
            game.firstTimePlayer = false;
            
            document.getElementById('introScreen').style.display = 'none';
            game.running = true;
            game.gameStarted = true;
            generateInitialPlatforms();
            initializeLivesDisplay();
        }
        
        
        function generateInitialPlatforms() {
            platforms = [];
            
            // Starting ground platform
            platforms.push({x: 0, y: 480, width: 360, height: 20, type: 'ground'});
            
            // Generate platforms going up
            for (let i = 1; i <= 20; i++) {
                let width = 80 + Math.random() * 100;
                let x = Math.random() * (360 - width);
                let y = 480 - (i * 70);
                
                platforms.push({
                    x: x,
                    y: y,
                    width: width,
                    height: 12,
                    type: 'platform'
                });
                
                highestPlatform = y;
            }
        }
        
        function generateMorePlatforms() {
            for (let i = 0; i < 5; i++) {
                let width = 80 + Math.random() * 100;
                let x = Math.random() * (360 - width);
                highestPlatform -= 70;
                
                platforms.push({
                    x: x,
                    y: highestPlatform,
                    width: width,
                    height: 12,
                    type: 'platform'
                });
            }
        }
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            game.keys[e.code] = true;
        });
        
        document.addEventListener('keyup', (e) => {
            game.keys[e.code] = false;
        });
        
        // ==========================================
        // üì± PROFESSIONAL MOBILE TOUCH CONTROLS
        // ==========================================
        
        // Touch control state management
        const touchControls = {
            enabled: false,
            leftZone: { active: false, touchId: null },
            rightZone: { active: false, touchId: null },
            jumpZone: { active: false, touchId: null },
            screenWidth: 0,
            screenHeight: 0,
            initialized: false
        };
        
        // Device detection with multiple fallbacks
        function detectTouchCapability() {
            return (
                'ontouchstart' in window ||
                navigator.maxTouchPoints > 0 ||
                navigator.msMaxTouchPoints > 0 ||
                window.DocumentTouch && document instanceof window.DocumentTouch
            );
        }
        
        // Initialize touch controls if touch device detected
        function initializeTouchControls() {
            if (touchControls.initialized) return;
            
            const isTouchDevice = detectTouchCapability();
            const isNarrowScreen = window.innerWidth < 768;
            
            if (isTouchDevice || isNarrowScreen) {
                touchControls.enabled = true;
                touchControls.screenWidth = canvas.clientWidth;
                touchControls.screenHeight = canvas.clientHeight;
                setupTouchEventListeners();
                showTouchHints();
                console.log('üéÆ Touch controls activated for mobile device');
            }
            
            touchControls.initialized = true;
        }
        
        // Show touch zone hints for mobile users
        function showTouchHints() {
            const hintsElement = document.getElementById('touchHints');
            if (!hintsElement) return;
            
            // Show hints immediately
            hintsElement.classList.add('visible');
            
            // Hide hints after 4 seconds of gameplay
            setTimeout(() => {
                if (game.jumps > 2) { // Only hide if user has started playing
                    hintsElement.classList.remove('visible');
                }
            }, 4000);
            
            // Also hide on first touch interaction
            let hasInteracted = false;
            const hideOnInteraction = () => {
                if (!hasInteracted) {
                    hasInteracted = true;
                    setTimeout(() => {
                        hintsElement.classList.remove('visible');
                    }, 2000);
                }
            };
            
            canvas.addEventListener('touchstart', hideOnInteraction, { once: true });
        }
        
        // ==========================================
        // üîç PERFORMANCE MONITORING & VALIDATION
        // ==========================================
        
        const performanceMonitor = {
            frameCount: 0,
            lastFpsCheck: performance.now(),
            currentFps: 60,
            inputLatencySum: 0,
            inputCount: 0,
            touchEventCount: 0,
            enabled: false
        };
        
        // Enable performance monitoring in debug mode
        function enablePerformanceMonitoring() {
            const urlParams = new URLSearchParams(window.location.search);
            performanceMonitor.enabled = urlParams.has('debug') || urlParams.has('perf');
            
            if (performanceMonitor.enabled) {
                console.log('üîç Performance monitoring enabled');
                setInterval(logPerformanceMetrics, 5000); // Log every 5 seconds
            }
        }
        
        // Track input latency for touch events
        function trackInputLatency(startTime) {
            if (!performanceMonitor.enabled) return;
            
            const latency = performance.now() - startTime;
            performanceMonitor.inputLatencySum += latency;
            performanceMonitor.inputCount++;
            
            if (latency > 50) {
                console.warn('‚ö†Ô∏è High input latency detected:', latency.toFixed(2) + 'ms');
            }
        }
        
        // Log performance metrics to console
        function logPerformanceMetrics() {
            if (!performanceMonitor.enabled) return;
            
            const avgInputLatency = performanceMonitor.inputCount > 0 
                ? (performanceMonitor.inputLatencySum / performanceMonitor.inputCount).toFixed(2)
                : 'N/A';
            
            console.log('üìä Performance Metrics:', {
                fps: performanceMonitor.currentFps,
                avgInputLatency: avgInputLatency + 'ms',
                touchEvents: performanceMonitor.touchEventCount,
                touchControlsActive: touchControls.enabled
            });
            
            // Reset counters
            performanceMonitor.inputLatencySum = 0;
            performanceMonitor.inputCount = 0;
            performanceMonitor.touchEventCount = 0;
        }
        
        // FPS calculation in game loop
        function updatePerformanceMetrics() {
            if (!performanceMonitor.enabled) return;
            
            performanceMonitor.frameCount++;
            const now = performance.now();
            
            if (now - performanceMonitor.lastFpsCheck >= 1000) {
                performanceMonitor.currentFps = performanceMonitor.frameCount;
                performanceMonitor.frameCount = 0;
                performanceMonitor.lastFpsCheck = now;
                
                // Alert if FPS drops significantly
                if (performanceMonitor.currentFps < 45) {
                    console.warn('‚ö†Ô∏è Low FPS detected:', performanceMonitor.currentFps);
                }
            }
        }
        
        // Setup optimized touch event listeners
        function setupTouchEventListeners() {
            // Remove legacy click handler to prevent conflicts
            canvas.removeEventListener('click', legacyClickHandler);
            
            // Multi-touch event handlers with passive optimization
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            canvas.addEventListener('touchcancel', handleTouchCancel, { passive: false });
            
            // Prevent context menu on long press (mobile Safari)
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Handle screen orientation/resize changes
            window.addEventListener('orientationchange', updateTouchZones);
            window.addEventListener('resize', updateTouchZones);
        }
        
        // Legacy click handler reference for removal
        function legacyClickHandler(e) {
            if (game.running && player.onGround) {
                player.velocityY = player.jumpPower;
                player.onGround = false;
                player.hasJumped = true;
            }
        }
        
        // Update touch zone dimensions on screen changes
        function updateTouchZones() {
            if (!touchControls.enabled) return;
            
            setTimeout(() => {
                touchControls.screenWidth = canvas.clientWidth;
                touchControls.screenHeight = canvas.clientHeight;
                console.log('üîÑ Touch zones updated:', touchControls.screenWidth + 'x' + touchControls.screenHeight);
            }, 100); // Small delay for orientation change completion
        }
        
        // Core touch event handlers with multi-touch support
        function handleTouchStart(e) {
            const startTime = performance.now();
            e.preventDefault(); // Prevent scrolling/zooming
            
            if (!game.running || !touchControls.enabled) return;
            
            performanceMonitor.touchEventCount++;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.clientWidth / rect.width;
            const scaleY = canvas.clientHeight / rect.height;
            
            Array.from(e.changedTouches).forEach(touch => {
                const touchX = (touch.clientX - rect.left) * scaleX;
                const touchY = (touch.clientY - rect.top) * scaleY;
                
                processTouchZone(touch.identifier, touchX, touchY, 'start');
            });
            
            trackInputLatency(startTime);
        }
        
        function handleTouchMove(e) {
            e.preventDefault(); // Prevent scrolling
            
            if (!game.running || !touchControls.enabled) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.clientWidth / rect.width;
            const scaleY = canvas.clientHeight / rect.height;
            
            Array.from(e.changedTouches).forEach(touch => {
                const touchX = (touch.clientX - rect.left) * scaleX;
                const touchY = (touch.clientY - rect.top) * scaleY;
                
                processTouchZone(touch.identifier, touchX, touchY, 'move');
            });
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            
            Array.from(e.changedTouches).forEach(touch => {
                releaseTouchZone(touch.identifier);
            });
        }
        
        function handleTouchCancel(e) {
            e.preventDefault();
            
            Array.from(e.changedTouches).forEach(touch => {
                releaseTouchZone(touch.identifier);
            });
        }
        
        // Intelligent touch zone processing
        function processTouchZone(touchId, x, y, eventType) {
            const leftBoundary = touchControls.screenWidth * 0.5; // Left 50% of screen
            const jumpTapThreshold = 150; // ms for tap vs hold detection
            
            if (x < leftBoundary) {
                // Left movement zone
                if (!touchControls.leftZone.active || touchControls.leftZone.touchId === touchId) {
                    touchControls.leftZone.active = true;
                    touchControls.leftZone.touchId = touchId;
                    
                    // Trigger jump on tap, movement on hold
                    if (eventType === 'start') {
                        if (player.onGround) {
                            // Immediate jump response for better feel
                            player.velocityY = player.jumpPower;
                            player.onGround = false;
                            player.hasJumped = true;
                        }
                        
                        // Start left movement after brief delay to distinguish tap vs hold
                        setTimeout(() => {
                            if (touchControls.leftZone.active && touchControls.leftZone.touchId === touchId) {
                                game.keys['TouchLeft'] = true;
                            }
                        }, jumpTapThreshold);
                    }
                }
            } else {
                // Right movement zone  
                if (!touchControls.rightZone.active || touchControls.rightZone.touchId === touchId) {
                    touchControls.rightZone.active = true;
                    touchControls.rightZone.touchId = touchId;
                    
                    // Trigger jump on tap, movement on hold
                    if (eventType === 'start') {
                        if (player.onGround) {
                            // Immediate jump response for better feel
                            player.velocityY = player.jumpPower;
                            player.onGround = false;
                            player.hasJumped = true;
                        }
                        
                        // Start right movement after brief delay
                        setTimeout(() => {
                            if (touchControls.rightZone.active && touchControls.rightZone.touchId === touchId) {
                                game.keys['TouchRight'] = true;
                            }
                        }, jumpTapThreshold);
                    }
                }
            }
        }
        
        // Clean touch zone release
        function releaseTouchZone(touchId) {
            if (touchControls.leftZone.touchId === touchId) {
                touchControls.leftZone.active = false;
                touchControls.leftZone.touchId = null;
                game.keys['TouchLeft'] = false;
            }
            
            if (touchControls.rightZone.touchId === touchId) {
                touchControls.rightZone.active = false;
                touchControls.rightZone.touchId = null;
                game.keys['TouchRight'] = false;
            }
        }
        
        // Legacy click support for non-touch devices
        canvas.addEventListener('click', legacyClickHandler);
        
        function updatePlayer() {
            if (!game.running) return;
            
            // Handle input (keyboard + touch unified)
            if (game.keys['ArrowLeft'] || game.keys['KeyA'] || game.keys['TouchLeft']) {
                player.velocityX = -player.speed;
            } else if (game.keys['ArrowRight'] || game.keys['KeyD'] || game.keys['TouchRight']) {
                player.velocityX = player.speed;
            } else {
                player.velocityX *= 0.8; // Friction
            }
            
            if ((game.keys['Space'] || game.keys['ArrowUp'] || game.keys['KeyW']) && player.onGround) {
                player.velocityY = player.jumpPower;
                player.onGround = false;
                player.hasJumped = true;
            }
            
            // Apply gravity
            player.velocityY += 0.8;
            
            // Update position
            player.x += player.velocityX;
            player.y += player.velocityY;
            
            // Screen wrapping
            if (player.x < 0) player.x = canvas.width - player.width;
            if (player.x > canvas.width) player.x = 0;
            
            // Check platform collisions
            let wasOnGround = player.onGround;
            player.onGround = false;
            
            for (let platform of platforms) {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {
                    
                    if (player.velocityY > 0 && player.y + player.height - player.velocityY <= platform.y + 5) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        
                        if (!wasOnGround && player.hasJumped) {
                            game.jumps++;
                            player.hasJumped = false;
                            checkLevelUp();
                        }
                        break;
                    }
                }
            }
            
            if (player.y < highestPlatform + 200) {
                generateMorePlatforms();
            }
        }
        
        function checkLevelUp() {
            let newLevel = Math.floor(game.jumps / 15) + 1;
            if (newLevel > game.level) {
                game.level = newLevel;
                game.lavaSpeed += 0.3;
                
                game.levelNotification.show = true;
                game.levelNotification.level = newLevel;
                game.levelNotification.timer = 120;
            }
        }
        
        function updateCamera() {
            if (player.y < game.highestPlayerY) {
                game.highestPlayerY = player.y;
            }
            
            let targetCameraY = game.highestPlayerY - 200;
            game.cameraY = Math.min(game.cameraY, targetCameraY);
        }
        
        function updateLevelNotification() {
            if (game.levelNotification.show) {
                game.levelNotification.timer--;
                if (game.levelNotification.timer <= 0) {
                    game.levelNotification.show = false;
                }
            }
        }
        
        function updateLava() {
            if (!game.running) return;
            
            game.lavaHeight += game.lavaSpeed;
            
            let lavaWorldY = 500 - game.lavaHeight;
            if (player.y + player.height >= lavaWorldY) {
                game.deathReason = "burned";
                gameOver();
                return;
            }
            
            let playerScreenY = player.y - game.cameraY;
            if (playerScreenY > canvas.height + 50) {
                if (!game.dyingState) {
                    game.dyingState = true;
                    game.deathTimer = 120;
                    
                    let lavaScreenY = lavaWorldY - game.cameraY;
                    if (lavaScreenY < canvas.height) {
                        game.deathReason = "fell";
                    } else {
                        game.deathReason = "offscreen";
                    }
                }
            }
            
            if (game.dyingState) {
                game.deathTimer--;
                if (game.deathTimer <= 0) {
                    gameOver();
                }
            }
        }
        
        function drawStickman(x, y) {
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            
            // Head
            ctx.beginPath();
            ctx.arc(x + 4, y + 3, 3, 0, Math.PI * 2);
            ctx.stroke();
            
            // Body
            ctx.beginPath();
            ctx.moveTo(x + 4, y + 6);
            ctx.lineTo(x + 4, y + 12);
            ctx.stroke();
            
            // Arms
            ctx.beginPath();
            if (!player.onGround) {
                ctx.moveTo(x + 4, y + 8);
                ctx.lineTo(x + 1, y + 5);
                ctx.moveTo(x + 4, y + 8);
                ctx.lineTo(x + 7, y + 5);
            } else {
                ctx.moveTo(x + 1, y + 8);
                ctx.lineTo(x + 7, y + 8);
            }
            ctx.stroke();
            
            // Legs
            ctx.beginPath();
            ctx.moveTo(x + 4, y + 12);
            ctx.lineTo(x + 1, y + 16);
            ctx.moveTo(x + 4, y + 12);
            ctx.lineTo(x + 7, y + 16);
            ctx.stroke();
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw platforms
            for (let platform of platforms) {
                let drawY = platform.y - game.cameraY;
                
                if (drawY > -20 && drawY < canvas.height + 20) {
                    if (platform.type === 'ground') {
                        ctx.fillStyle = '#8B4513';
                    } else {
                        ctx.fillStyle = '#228B22';
                    }
                    
                    ctx.fillRect(platform.x, drawY, platform.width, platform.height);
                    
                    ctx.fillStyle = '#32CD32';
                    ctx.fillRect(platform.x, drawY, platform.width, 2);
                }
            }
            
            // Draw player
            let playerDrawY = player.y - game.cameraY;
            if (playerDrawY <= canvas.height + 50) {
                drawStickman(player.x, playerDrawY);
            }
            
            // Draw lava
            if (game.lavaHeight > 0) {
                let lavaWorldY = 500 - game.lavaHeight;
                let lavaScreenY = lavaWorldY - game.cameraY;
                
                if (lavaScreenY < canvas.height) {
                    let visibleLavaHeight = canvas.height - Math.max(0, lavaScreenY);
                    let drawStartY = Math.max(0, lavaScreenY);
                    
                    let gradient = ctx.createLinearGradient(0, drawStartY, 0, canvas.height);
                    gradient.addColorStop(0, '#ff6b6b');
                    gradient.addColorStop(0.5, '#ff4757');
                    gradient.addColorStop(1, '#ff3742');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, drawStartY, canvas.width, visibleLavaHeight);
                    
                    // Lava bubbles
                    ctx.fillStyle = '#ffda79';
                    for (let i = 0; i < 10; i++) {
                        let bubbleX = Math.random() * canvas.width;
                        let bubbleY = drawStartY + Math.random() * Math.min(visibleLavaHeight, 50);
                        let size = 2 + Math.random() * 4;
                        
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    if (lavaScreenY > -50 && lavaScreenY < canvas.height - 50) {
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 12px Courier New';
                        ctx.textAlign = 'center';
                        ctx.fillText('üî• LAVA RISING! üî•', canvas.width/2, Math.max(20, lavaScreenY - 10));
                    }
                }
            }
            
            // Death countdown
            if (game.dyingState) {
                let countdown = Math.ceil(game.deathTimer / 60);
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(`üíÄ ${countdown}`, canvas.width/2, canvas.height/2);
                
                ctx.font = 'bold 12px Courier New';
                ctx.fillText('Fell off screen!', canvas.width/2, canvas.height/2 + 30);
            }
            
            // Level up notification
            if (game.levelNotification.show) {
                let opacity = game.levelNotification.timer / 120;
                
                ctx.fillStyle = `rgba(0, 255, 136, ${opacity * 0.4})`;
                ctx.fillRect(0, 100, canvas.width, 80);
                
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.font = 'bold 18px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('üéâ LEVEL UP! üéâ', canvas.width/2, 130);
                
                ctx.font = 'bold 14px Courier New';
                ctx.fillText(`REACHED LEVEL ${game.levelNotification.level}`, canvas.width/2, 150);
            }
        }
        
        function updateUI() {
            document.getElementById('jumps').textContent = game.jumps;
            document.getElementById('level').textContent = game.level;
            document.getElementById('speed').textContent = game.lavaSpeed.toFixed(1) + 'x';
        }
        
        function gameOver() {
            game.running = false;
            game.dyingState = false;
            
            // Use a life
            const canContinue = useLive();
            
            if (!canContinue) {
                // No lives left - show game over
                if (game.deathReason === "fell") {
                    document.getElementById('gameOverTitle').textContent = "üíÄ NO LIVES LEFT!";
                    document.getElementById('gameOverMessage').textContent = "You fell into lava and ran out of lives!";
                } else if (game.deathReason === "offscreen") {
                    document.getElementById('gameOverTitle').textContent = "üíÄ NO LIVES LEFT!";
                    document.getElementById('gameOverMessage').textContent = "You fell too far and ran out of lives!";
                } else {
                    document.getElementById('gameOverTitle').textContent = "üî• NO LIVES LEFT!";
                    document.getElementById('gameOverMessage').textContent = "The lava caught you and you're out of lives!";
                }
                
                document.getElementById('finalJumps').textContent = game.jumps;
                document.getElementById('finalLevel').textContent = game.level;
                
                document.getElementById('gameOver').style.display = 'block';
            } else {
                // Still have lives - show continue screen
                console.log('‚ù§Ô∏è Life used, showing continue screen...');
                
                // Reset game state but don't auto-start
                const wasFirstTime = game.firstTimePlayer;
                game = {
                    jumps: 0,
                    level: 1,
                    lavaSpeed: 0.5,
                    lavaHeight: 0,
                    running: false,
                    introStep: 0,
                    keys: {},
                    gameStarted: false,
                    cameraY: 0,
                    highestPlayerY: 460,
                    deathReason: "burned",
                    deathTimer: 0,
                    dyingState: false,
                    firstTimePlayer: wasFirstTime,
                    levelNotification: {
                        show: false,
                        level: 1,
                        timer: 0
                    }
                };
                
                window.game = game; // Update global reference
                
                player = {
                    x: 180,
                    y: 460,
                    width: 8,
                    height: 16,
                    velocityX: 0,
                    velocityY: 0,
                    onGround: true,
                    jumpPower: -15,
                    speed: 5,
                    hasJumped: false
                };
                
                platforms = [];
                highestPlatform = 480;
                
                // Hide game over modal and show continue screen
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('introScreen').style.display = 'block';
                document.getElementById('introText').textContent = "üíÄ Oops! You died but have lives remaining. Ready to try again?";
                document.getElementById('continueBtn').textContent = "Try Again!";
                document.getElementById('continueBtn').className = "btn";
                document.getElementById('continueBtn').onclick = startGame;
            }
        }
        
        function restartGame() {
            // Preserve first-time status
            const wasFirstTime = game.firstTimePlayer;
            
            // Reset lives to 3
            userLives = 3;
            updateLivesDisplay();
            
            game = {
                jumps: 0,
                level: 1,
                lavaSpeed: 0.5,
                lavaHeight: 0,
                running: false,
                introStep: 0,
                keys: {},
                gameStarted: false,
                cameraY: 0,
                highestPlayerY: 460,
                deathReason: "burned",
                deathTimer: 0,
                dyingState: false,
                firstTimePlayer: wasFirstTime, // Preserve first-time status
                levelNotification: {
                    show: false,
                    level: 1,
                    timer: 0
                }
            };
            
            window.game = game; // Update global reference
            
            player = {
                x: 180,
                y: 460,
                width: 8,
                height: 16,
                velocityX: 0,
                velocityY: 0,
                onGround: true,
                jumpPower: -15,
                speed: 5,
                hasJumped: false
            };
            
            platforms = [];
            highestPlatform = 480;
            
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('introScreen').style.display = 'block';
            
            // Set button behavior based on whether it's first time
            if (wasFirstTime) {
                // First time - show full intro sequence
                document.getElementById('introText').textContent = "Everything seems normal...";
                document.getElementById('continueBtn').textContent = "Continue";
                document.getElementById('continueBtn').className = "btn";
                document.getElementById('continueBtn').onclick = nextIntroStep; // Use intro sequence
                game.introStep = 0; // Reset intro step
            } else {
                // Not first time - direct restart
                document.getElementById('introText').textContent = "üéÆ Ready to escape the lava again?";
                document.getElementById('continueBtn').textContent = "Let's Go!";
                document.getElementById('continueBtn').className = "btn";
                document.getElementById('continueBtn').onclick = startGame; // Direct start, skip intro
            }
        }
        
        function gameLoop() {
            if (!game.running) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            updatePlayer();
            updateCamera();
            updateLevelNotification();
            updateLava();
            draw();
            updateUI();
            updatePerformanceMetrics(); // Performance monitoring
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize game
        generateInitialPlatforms();
        initializeTouchControls(); // Initialize mobile touch controls
        enablePerformanceMonitoring(); // Enable performance tracking if debug mode
        gameLoop();
        
        
        // Initialize lives display when game starts
        function initializeLivesDisplay() {
            updateLivesDisplay();
        }
        
        // Check if player can start game
        function canStartGame() {
            return userLives > 0;
        }
        
        // Leaderboard Functions
        async function showLeaderboard() {
            const modal = document.getElementById('leaderboardModal');
            const content = document.getElementById('leaderboardContent');
            
            modal.style.display = 'flex';
            content.innerHTML = '<p>Loading leaderboard...</p>';
            
            try {
                const leaderboard = await window.blockchain.getLeaderboard();
                
                if (leaderboard.length === 0) {
                    content.innerHTML = '<p>No scores yet. Be the first to set a record!</p>';
                    return;
                }
                
                let html = '';
                leaderboard.forEach((entry, index) => {
                    const rank = index + 1;
                    const address = typeof entry.player === 'string' ? 
                        entry.player.slice(0, 6) + '...' + entry.player.slice(-4) :
                        'Unknown';
                    const jumps = parseInt(entry.jumps);
                    const level = parseInt(entry.level || 1);
                    
                    const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : 'üèÖ';
                    
                    html += `
                        <div class="leaderboard-entry">
                            <span class="player-rank">${medal} ${rank}</span>
                            <div>
                                <div class="player-address">${address}</div>
                                <div>Level ${level}</div>
                            </div>
                            <span class="player-score">${jumps} jumps</span>
                        </div>
                    `;
                });
                
                content.innerHTML = html;
                
            } catch (error) {
                console.error('Failed to load leaderboard:', error);
                content.innerHTML = '<p>Failed to load leaderboard. Try again later.</p>';
            }
        }
        
        function closeLeaderboard() {
            document.getElementById('leaderboardModal').style.display = 'none';
        }
        
        console.log('üéÆ Game initialized successfully');
    </script>
</body>
</html>